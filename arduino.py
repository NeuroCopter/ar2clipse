# -*- coding: utf-8 -*-

import os

class big_cpp_file:
    """
    this class represents the big *.cpp file that the arduino "IDE" / ArduCopter-makefile creates out of the *.pde files.
    """

    def __init__(self, path):
        """
        @param path: path to the cpp file
        @type path: string
        """
        self._path = path
        with open(path) as f:
            txt = f.read()
        self._lines = txt.splitlines()

    def split_into_pdes(self, out_dir):
        """
        splits the file into the *.pde files it was creates from.
        print some infos while doing this.
        @param out_dir: directory to write the *.pde files into
        @type out_dir: string
        """
        d = {}
        current_file = None

        for line in self._lines:
            if line.startswith("#line "):
                prefix, num, path = line.split(" ", 2)
                num = int(num)
                path = path[1:-1] # remove quotes
                path = path.rsplit('/',1)[-1] # retrieve filename out of path
                print '%s %4d "%s"' %(prefix, num, path)

                current_file = path
                if current_file not in d:
                    d[current_file] = []
            else:
                d[current_file].append(line)
        # write files
        for file_name in d:
            with open( os.path.join(out_dir, file_name) ,'w') as f:
                for line in d[file_name]:
                    f.write(line + '\n')
        return

    def build_main_cpp(self, out_path):
        """
        creates a file that corresponds to the "big *.cpp" file where the pde code is replaced by includes.
        
        assumed structure of the big cpp file:
            - beginning of "main-pde" (all includes)
            - autogenerated forward declarations
            - rest of "main-pde"
            - code of all other *.pde files
 
        structure of created file:
            - beginning of "main-pde" (all includes)
            - autogenerated forward declarations
            - inlcude "main-pde.hpp"
            - inlcude of all other *.pde files as *.pde.hpp
            
        @param out_path: path to file that is created
        @type out_path: string
        """

        result = ['/* BEGINNING OF "MAIN" PDE FILE */', ""]

        it = iter(self._lines)
        
        # skip '#line 1 "..../ardupilot/ArduCopter/ArduCopter.pde"'
        it.next()
        
        for line in it:
            if line == '#line 1 "autogenerated"':
                result.append("")
                result.append("/* <AUTOGENERATED> */")
                result.append("")
                continue
            # '#line 123 "..../ardupilot/ArduCopter/ArduCopter.pde"'
            if line.startswith("#line "):
                result.append("")
                result.append("/* </AUTOGENERATED> */")
                result.append("")
                result.append('#include "%s.hpp"' %line[:-1].rsplit('/')[-1])
                break
            result.append(line)
            
        for line in it:
            if line.startswith("#line "):
                result.append('#include "%s.hpp"' %line[:-1].rsplit('/')[-1])            

        with open(out_path, 'w') as f:
            for line in result:
                f.write(line + '\n')
        return

    def get_includes(self):
        """
        searches the file for all #include statements.
        @see: http://gcc.gnu.org/onlinedocs/cpp/Include-Syntax.html

        @return: (list of user headers, list of system headers)
        @rtype: (list of strings, list of strings)
        """
        user_headers = []
        system_headers = []
        for line in self._lines:
            if line.startswith("#include"):
                line = line.split('//')[0].strip()
                if line.endswith('"'):
                    header = line[:-1].rsplit('"', 1)[-1]
                    user_headers.append(header)
                elif line.endswith('>'):
                    header = line[:-1].rsplit('<', 1)[-1]
                    system_headers.append(header)
                else:
                    raise ValueError("ill-formed inlude: " + line)
        return user_headers, system_headers

class arduino_lib:
    """
    this class provides some functionality around the arduino libraries directory.
    
    assumed structure of that directory:
        $LIBNAME$/$LIBNAME$.h
        
    including a system-header $SH$ in a *.pde file causes the arduino "IDE" to add "libraries/$SH$"
    to the search path i.e. "g++ ... -I libraries/$SH$ ..."
    
    because writing '#include <$SH$/$SH$.h>' or '#include "libraries/$SH$/$SH$.h"'
    is probably too much of a challenge for an unexperienced user who on the other
    hand is expected to write hardware-near C/C++ ...
    """

    def __init__(self, libraries_path):
        """
        @param libraries_path: path to arduino libraries directory
        @type libraries_path: string
        """
        self._libraries_path = libraries_path

    def get_header_libs(self):
        """
        @return: {header_name : [lib containing header]}, [list of all libs]
        @rtype: {string : list of strings}, list of strings
        """
        d = {}
        libs = []
        
        for f in os.listdir(self._libraries_path):
            f_path = os.path.join(self._libraries_path, f)
            if os.path.isdir(f_path):
                libs.append(f)
                for f2 in os.listdir(f_path):
                    if f2.endswith(".h") or f2.endswith(".hpp"):
                        d[f2] = d.get(f2, []) + [f]
        return d, libs


    def get_libs_usage(self, include_list):
        """
        searches the libraries directory for a list of passed headers
        
        @param include_list: list of header-filenames
        @type include_list: list of strings

        @return: list of libs that contain the passed headers, list of unused libs, list of headers that weren't found in any lib
        @rtype: list of strings, list of strings, list of strings
        """
        result_used = []
        result_used_but_not_found = []
        result_unused = []
        
        header_lib_dict, libs = self.get_header_libs()

        for header in include_list:
            if header in header_lib_dict:
                if len(header_lib_dict[header]) != 1:
                    raise ValueError("header (%s) in multiple libs (%r) --> not uniquely assignable :(" %(header, header_lib_dict[header]) )
                result_used.append( header_lib_dict[header][0] )
            else:
                result_used_but_not_found.append(header)

        for lib in libs:
            if lib not in result_used:
                result_unused.append(lib)
                
        return result_used, result_unused, result_used_but_not_found
        
        
    def create_eclipse_include_paths(self, project_name, include_list, libraries_dir = "libraries"):
        """
        creates a list of eclipse-worspace-inlcude-paths out of a list of used header.
        i.e. "${workspace_loc:/$project_name$/$libraries_dir$/$DIR$}"
        
        @param project_name: name of an eclipse project
        @type project_name: string
        @param include_list: list of header filenames
        @type include_list: list of strings
        @param libraries_dir: name of the "arduino libraries" directory inside the eclipse project
        @type libraries_dir: string
        
        @see: get_libs_usage 
        
        @return: list of eclipse workspace inlcude paths
        @rtype: list of strings
        """
        return ['"${workspace_loc:/%s}"' %( os.path.join(project_name, libraries_dir, lib) ) for lib in self.get_libs_usage(include_list)[0] ]

    def create_eclipse_unused_libs_exclude(self, include_list, libraries_dir = "libraries", exclude_lib_subdir = ["examples"]):
        """
        creates a list of exclude paths for unused libraries out of a list of used headers.
        also excludes some subdirectories of used libraries.  
        
        @param include_list: list of header filenames
        @type include_list: list of strings
        @param libraries_dir: name of the "arduino libraries" directory inside the eclipse project
        @type libraries_dir: string
        @param exclude_lib_subdir: names of subdirectories of used libs to be excluded
        @type exclude_lib_subdir: list of strings
        
        @return: list of paths of libraries and library-subdirectories
        @rtype: list of strings
        """
        result = []
        used, unused, _ = self.get_libs_usage(include_list)
        for lib in unused:
            result.append( os.path.join(libraries_dir, lib) )

        for lib in used:
            for subdir in exclude_lib_subdir:
                lib_subdir = os.path.join(lib, subdir)
                if os.path.exists( os.path.join(self._libraries_path, lib_subdir) ):
                    result.append( os.path.join(libraries_dir, lib_subdir) )

        return result

if __name__ == "__main__":
    """
    demonstrates the usage of the classes.
    """

    # replaces this with your libraries folder - is used read-only
    libraries_path    = "/home/tobias/git/ardupilot/libraries/"

    big_cpp_file_path = "example_files/ArduCopter.cpp"
    project_name      = "ArduCopter"
    pde_dir           = "example_files/out"
    altered_cpp_path  = "example_files/out.ArduCopter.cpp"


    cpp_file = big_cpp_file( big_cpp_file_path )
    cpp_file.split_into_pdes( pde_dir )
    cpp_file.build_main_cpp( altered_cpp_path )
    user_headers, system_headers = cpp_file.get_includes()

    ardu_lib = arduino_lib(libraries_path)
    
    print "ECLIPSE INCLUDES:"
    print '\n'.join( ardu_lib.create_eclipse_include_paths(project_name, system_headers) )
    print

    print "ECLIPSE EXCLUDES:"
    print '\n'.join( ardu_lib.create_eclipse_unused_libs_exclude(system_headers) )
